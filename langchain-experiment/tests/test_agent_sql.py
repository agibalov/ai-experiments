from pathlib import Path
from typing import Type
from langchain.chat_models import init_chat_model
from langgraph.checkpoint.memory import MemorySaver
from langgraph.prebuilt import create_react_agent
from langchain_core.tools import ToolException, BaseTool
from langchain_core.messages import HumanMessage
from langgraph.graph.state import CompiledStateGraph
from pydantic import BaseModel, Field
import sqlite3
import pytest

from tabulate import tabulate

from expert import assert_text_entails_claim
from debug_utils import pretty_agent_output

class RunSqlArgs(BaseModel):
    query: str = Field(..., description="Full SQL with concrete values; no '?' placeholders.")


class DatabaseTool(BaseTool):
    name: str = "db_tool"
    description: str = "Tool for querying a SQL database."
    args_schema: Type[BaseModel] = RunSqlArgs
    handle_tool_error = lambda e: f"{e}"
    conn: sqlite3.Connection

    def _run(self, query: str) -> str:
        print(f"Running SQL: {query}")

        try:
            self.conn.execute("EXPLAIN " + query)
        except sqlite3.Error as e:
            print(f"Invalid SQL: {e}")
            raise ToolException(f"INPUT_ERROR: Invalid SQL - {e}")

        try:
            cur = self.conn.cursor()
            cur.execute(query)
            rows = cur.fetchall()
            cols = [d[0] for d in cur.description]
            return tabulate(rows, headers=cols, tablefmt="github")
        except Exception as e:
            print(f"Error running SQL: {e}")
            raise ToolException(f"INPUT_ERROR: Error running SQL - {e}")

def get_schema(conn: sqlite3.Connection) -> str:
    rows = conn.execute("""
        SELECT sql || ';'
        FROM sqlite_schema
        WHERE type='table' AND name NOT LIKE 'sqlite_%'
        ORDER BY name
    """).fetchall()

    return "\n\n".join(r[0] for r in rows if r[0])

def make_db():
    conn = sqlite3.connect(":memory:", check_same_thread=False)
    conn.executescript("""
        PRAGMA journal_mode=OFF;
        PRAGMA synchronous=OFF;
        PRAGMA temp_store=MEMORY;
    """)
    script = Path("Chinook_Sqlite.sql").read_text(encoding="utf-8")
    conn.executescript(script)

    return conn    

@pytest.fixture(params=["ollama:llama3.2:3b", "ollama:gpt-oss:20b"],
                ids=lambda v: "model_" + v.replace(":", "_").replace(".", "_").replace("-", "_"))
def model_name(request) -> str:
    return request.param

@pytest.fixture(params=[0.0, 0.2, 0.6, 1.0], 
                ids=lambda v: f"temp_{v:g}".replace(".", "_"))
def temp(request) -> float:
    return request.param

@pytest.fixture(params=[0, 1337, 2302, 31337], 
                ids=lambda v: f"seed_{v}")
def seed(request) -> int:
    return request.param

"""
This prompt has been generated by ChatGPT 5 using the following instructions:

Generate a system prompt for an LLM agent based on gpt-oss:20b. This agent is a human 
interface to a database. User will ask questions about the data in the database, and 
agent should answer them. Agent should always base its answers on the data from the 
database. Agent has access to the tool "db_tool" which executes SQL queries against 
the database. Agent should always use Sqlite dialect. Agent should always interpolate
query parameters. It should not use '?' placeholders, because parameter binding is not 
available. Database schema will be provided as a part of this prompt in section 
"DATABASE SCHEMA". Write your answer as a python function:
```
def make_prompt(schema: str) -> str:
  return f""""""
prompt here
""""""
```
"""
def make_prompt(schema: str) -> str:
  return f"""
ROLE
You are a database Q&A agent (based on gpt-oss:20b). You answer questions **only** using 
data you fetch from the database via the tool `db_tool`.

HARD RULES
- Always use **SQLite** dialect.
- Always get facts by calling `db_tool` with a complete SQL string; never guess or rely 
on prior world knowledge.
- **Do not** use parameter placeholders (no ? or named parameters). You must inline all 
literal values safely (see Safe Interpolation Rules).
- Keep replies concise. Start with the direct answer. Add a small markdown table of 
relevant rows when helpful (default limit 50).
- If no rows match, say so clearly.
- Default to read-only. Perform INSERT/UPDATE/DELETE only if the user explicitly asks; 
restate intended change and ask for one-shot confirmation before executing.
- Never interpolate user input as identifiers (table or column names). Only use 
identifiers present in the schema.
- If a query errors, correct it and retry. If the request is ambiguous or would return 
too many rows, ask a targeted clarification.

TOOL: db_tool
- Executes one SQL statement and returns rows.
- Call it whenever you need data. Multi-step questions may require multiple calls.
- Provide a fully formed SQLite query string as the tool input.

SAFE INTERPOLATION RULES (since binding is unavailable)
1) Text literals: wrap in single quotes and escape internal single quotes by doubling 
them.
   Example: O'Reilly -> 'O''Reilly'
2) Integers: accept only digits with optional leading minus. If not matching, ask user 
to rephrase.
   Pattern: ^-?[0-9]+$
3) Floats: digits with optional decimal point and optional leading minus.
   Pattern: ^-?[0-9]+(\\.[0-9]+)?$
4) Lists: sanitize each element per its type and join with commas inside parentheses.
   Example: IN ('a','b','c') or IN (1,2,3)
5) Dates/times: prefer ISO strings like '2024-03-01' or '2024-03-01 14:30:00'
6) Booleans: use 1 for true and 0 for false (or compare to 1/0)
7) NULL checks: use IS NULL / IS NOT NULL (not = NULL)
8) Identifiers: never inline user-provided text as table/column names. Use only names 
found in the schema below.

SQLITE DIALECT REMINDERS
- Use double quotes for identifiers when needed; single quotes for text.
- String concatenation: ||
- No FULL OUTER JOIN; use LEFT JOIN where appropriate.
- Case-insensitive matching: ... COLLATE NOCASE or use LOWER(...)
- Current time utilities: date('now'), datetime('now'), CURRENT_TIMESTAMP
- Determinism: when returning lists, include ORDER BY; default LIMIT 50 unless the user 
requests otherwise.

QUERY CONSTRUCTION GUIDELINES
- Derive the simplest correct SQL that answers the question. Prefer computing aggregates 
(COUNT, SUM, AVG, MIN, MAX) in SQL.
- Select only needed columns; alias for clarity when helpful.
- When filtering by text, use LIKE with percent wildcards and escape percent/underscore 
if necessary.
- For multi-hop tasks (e.g., compute, then filter), run multiple `db_tool` calls as needed.
- If the user supplies raw SQL, validate it against rules above and the schema before 
executing; rewrite safely if needed.

RESPONSE STYLE
- First line: the direct answer derived from the latest query results.
- Then, if useful, a compact markdown table of key columns (up to 50 rows). Omit verbose 
SQL unless the user asks.
- If the schema cannot satisfy the request, briefly explain what is missing and ask a 
focused follow-up.

DATABASE SCHEMA
{schema}
"""

@pytest.fixture
def agent(model_name: str, temp: float, seed: int) -> CompiledStateGraph:
    conn = make_db()
    database_tool = DatabaseTool(conn=conn)
    
    memory = MemorySaver()
    model = init_chat_model(model_name, temperature=temp, seed=seed, num_ctx=4096)
    tools = [database_tool]
    agent = create_react_agent(
        model.bind_tools(tools), 
        tools, 
        checkpointer=memory, 
        prompt=make_prompt(get_schema(conn)))
    return agent

def test_count_customers(agent: CompiledStateGraph):
    out = agent.invoke(
        {"messages": [HumanMessage("How many customers are there?")]},
        config={"configurable": {"thread_id": f"andrey-1"}}, 
        recursion_limit=10
    )
    response = out["messages"][-1].content
    print(f"Response: {response}")
    assert_text_entails_claim(response, "text contains number 59")
    pretty_agent_output(out)

def test_count_customer_invoices(agent: CompiledStateGraph):
    out = agent.invoke(
        {"messages": [HumanMessage("How many invoices does customer Jack Smith have?")]},
        config={"configurable": {"thread_id": f"andrey-1"}}, 
        recursion_limit=10
    )
    response = out["messages"][-1].content
    print(f"Response: {response}")
    assert_text_entails_claim(response, "text contains number 7")
    pretty_agent_output(out)

def test_find_top_3_customers(agent: CompiledStateGraph):
    out = agent.invoke(
        {"messages": [HumanMessage("Who are top 3 customers by total amount of money spent? Show their names and spendings.")]},
        config={"configurable": {"thread_id": f"andrey-1"}}, 
        recursion_limit=10
    )
    response = out["messages"][-1].content
    print(f"Response: {response}")
    assert_text_entails_claim(response, "Helena Hol√Ω is associated with $49.62")
    assert_text_entails_claim(response, "Richard Cunningham is associated with $47.62")
    assert_text_entails_claim(response, "Luis Rojas is associated with $46.62")
    pretty_agent_output(out)
